# 实验二问答

## 1 PPT相关内容

1. 实模式下的寻址方式以及实模式的缺陷

   地址由偏移和段两部分组成

   物理地址（physical address) = 段值（Segment) * 16 + 偏移（offset）

   缺陷：1. 寻址能力不够 2. 通过改变段寄存器的值可以随心所欲的访问内存任何一个单元而不受限制。而不对内存访问加以限制，就无法对系统进行保护。



2. 保护模式下的寻址过程

   * 段寄存器中存储的是什么
   * GDT是什么？LDT是什么？LDT和GDT的区别？
   * 如何定位到Descriptor?Descriptor的内容

   ​

   段寄存器中存储的是 选择子 selector

   GDT Global Descriptor Table.存放Descriptor的表，可以在全局访问。所有进程想要访问全局可见的段时，从GDT查询，有且只有一个。进程从GDTR寄存器中获得GDT的位置。向它发起查询。

   LDT Local Descriptor Table. 不是全局的，对于某个进程，只知道自己的LDT。每个进程都有自己的LDT，访问自己的段时，从LDT查询。进程从LDTR寄存器中获得LDT的位置，向它发起查询。

   GDT是全局的，且只有一个。LDT是每个进程都有一个，每个进程只要可以查询自己的LDT

   ​

3. 选择子的作用

   1. 选择子是什么?它的值存放在哪里
   2. 选择子里面的内容有哪些
   3. 为什么偏移地址大小是13位

   2字节的数。16位。 存放在段寄存器中。

   描述符索引 13位 TI 1位 RPL 请求特权级 2位 TI 值只有1位0和1,0 代表在LDT中选择，1代表选择子在LDT中选择。

   13位给出了所需的描述符在描述符表中的位置，13位刚好足够寻址8K项



4. 描述符的作用

   描述符中有段基地址、属性和段界限。地址转换通过描述符来完成。

5. GDTR/LDTR的作用

   1. GDTR的内容
   2. LDTR的内容
   3. LDT为什么要放在GDT中

GDTR 表示GDT在内存中的段地址和段限（表的大小） 48位的寄存器，32位表示段地址，16位表示段限。

LDTR 只存放一个选择子。表示LDT在内存中的位置,LDT本身也是一种数据段，有一描述符，必须放在GDT中。通过查GDT获得真正的内存位置

描述符本身的结构除bit3外完全一样。 GDT表只有一个，且是固定的。LDT表每个任务都可以有一个。因此可以有多个，并且由于任务的个数在不断变化其数量也在不断变化。 只有一个LDTR寄存器不能满足多个LDT的要求

6. 根目录大小一定么？扇区号是多少？为什么？

根目录区大小不固定，需要计算。19号扇区开始。因为引导扇区1扇区，FAT表2个共18扇区。因为一个条目为32字节，所以根目录大小为 BPB_RootEntCnt（根目录文件最大数 ）* 32字节



7. 数据区的第一个簇号是多少，为什么？

      2 。 FAT（File Allocation Table)文件分配表的前三个字节必须是固定的,0xF0,0xFF,0xFF。表示应用在1.44M软盘上的FAT12文件系统，簇号0和1就没有存在的价值，所以数据区起始于簇2 

8. FAT表的作用

   文件分配表里有紧密排列的若干个表项，每个表项都与数据区的一个簇相对应，表项的序号也是与簇号意义对应的。

   FAT项的值代表文件的下一个簇号

   值大于或等于0xFF8,表示当前簇已经是本文件的最后一个簇

   值为0xFF7表示是一个坏簇

9. 解释静态连接的过程

静态链接：静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处。使用静态链接生成的可执行文件体积较大，包含相同的公共代码造成浪费。

链接器首先会进行地址和空间的重定位，然后会通过符号表，可重定位表解析符号，找到需要被重定位的符号，然后进行符号的重定位。更通俗一点讲，如同拼图游戏一样，先完成基本轮廓的拼图，中间偶尔会空几个难解的图块，我们先暂时不管（类似于编译器直接假设地址为0），可以在一张表中记录其缺失位置，然后会剩下几个难解的图块，你可以给它们也编一个号，和上表进行关联，最后把对照它们的位置信息，把图块补上，即对应于符号的重定位和解析了。

* 空间与地址分配。扫描所有文件，获得各个段的长度，属性和起始地址。合并各个目标文件的全局的符号表。
* 符号解析和重定位
  * 对于指令中引用其他目标文件中的符号找到符号的正确地址，也就是在全局符号表中找到对应的地址
  * 修正指令对引用其他目标文件的函数或变量的地址，未确定之前用的都是假地址。

10. 解释动态链接的过程

把链接这个过程推迟到了运行时再运行，这就是动态链接（Dynamic Linking)的基本思想。

并不一定在一开始就完成动态链接而是直到真正调用动态库代码时，载入程序才计算（被调用的那部分）动态代码的逻辑地址。

1.动态链接的装载。首先操作系统会读取可执行文件的头部，检查文件的合法性，之后从头部中的"Program Header"中读取每个"Segment"的虚拟地址、文件地址和属性，并将其映射到进程虚拟空间的相应位置。

2.如果是静态链接，上述过程之后，操作系统就会把控制权交给可执行文件的入口地址，但是在动态链接中，操作系统接下来会启动一个动态链接器。

3.在Linux下，动态链接器ld.so实际上是一个共享对象，操作系统同样通过映射的方式将其加载到进程的地址空间。当动态链接器得到控制权之后，它就开始执行一系列的自身的初始化操作，然后根据当前的环境参数对可执行文件进行动态链接工作。

4.当所有的动态链接工作完成之后，动态链接器将控制权交给可执行文件，程序开始正式执行。

1. 动态连接器自举
2. 装载共享对象
3. 重定位和初始化。



11. 静态链接相关PPT中为什么使用ld链接而不是gcc

为了加深我们的理解。gcc可能会找不到printf函数。所以需要ld添加参数来引用标准库。

12. linux下可执行文件的虚拟地址空间默认从哪里开始分配

**0X08048000 **32位

0x00400000 64位

## 2 实验相关内容

1. BPB指定字段的含义
2. 如何进入子目录并输出（说明方法调用）
3. 如何获得指定文件的内容，即如何获得数据区的内容（比如如何使用指针）
4. 如何进行C代码和汇编直接的参数传递和返回值返回
5. 汇编代码中对于I/O 的处理方式，说明指定寄存器所存值的含义

